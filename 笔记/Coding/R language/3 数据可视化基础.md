
#  正态分布（_Normal distribution_）

也称常态分布；高斯分布。  
若随机变量 X 服从一个数学期望为 `μ`、[[1 基本数据运算#^591212|方差]]为 `σ^2` 的正态分布，记为 N (μ，σ^2)。其概率密度函数为正态分布的期望值 **μ** 决定了其位置，其标准差**σ** 决定了分布的幅度。
函数为：
$$
\begin{array}{l}
P(x)=\frac{1}{\sigma \sqrt{2 \pi}} e^{-\frac{1}{2}\left(\frac{x-\mu}{\sigma}\right)^{2}} \\
\\
x \sim N\left(\mu, \sigma^{2}\right)
\end{array}
$$
图像为：
![[../../assets/Coding/Normal distribution.png]]
Note：当 *μ = 0, σ = 1* 时的正态分布是标准正态分布。

## 内置正态分布函数 - `norm()`
```R
dnorm(x, mean, sd)
rnorm(n, mean, sd)
```
参数：
-   _x_ - 数字的向量。
-   _n_ - 观察次数 (样本量)
-   _mean_ - 样本数据的平均值，默认值为零
-   _sd_ - 标准偏差，默认值为 `1`

**_dnorm_** 返回值是正态分布概率密度函数值，比如 dnorm(a) 表示：标准正态分布密度函数 f(x) 在 x=a 处的函数值.
```R
dnorm(2, mean = 5, sd = 3)
---
0.08065691
```

```R
z_scores <- seq(-3, 3, by = .1) 
dvalues <- dnorm(z_scores)
plot(z_scores, dvalues, 
	 xaxt = "s",  # 显示x轴的数值，默认为s，要不显示需改为n
	 type = "l",  # 改为线图而不是默认的点图
	 xlab= "Z-score" # 修改x轴名称
	 ) 
```
![[../../assets/Data Analysis/dnorm.png|400]]

**_rnorm_** 返回值是 n 个正态分布随机数构成的向量.
```R
x <- rnorm(1000,30,10)
hist(x)
```
![[../../assets/Data Analysis/rnorm.png|400]]


# `ggplot`可视化

## 有关`geom_...()`
ggplot2 的语法与 base r 不同。根据基本元素，默认的 ggplot 需要指定三样东西：数据，美学和几何形状。

```R
library(vroom)
library(tidyverse)
library(ggplot2)

chic <- vroom("https://raw.githubusercontent.com/onlyphantom/ggplot2cheatsheet/master/chicago-nmmaps.csv")
head(chic, n = 10)

g <- ggplot(chic, aes(x = date, y = temp)) # 在 aes () 外部指定数据，即 chic，并将映射到美学的数据变量 (即 date 和 temp) 添加到 aes () 内部。
g
```
![[../../assets/Data Analysis/ggplot1.png|400]]
仅使用ggplot后，得到的结果只是一个表格背景，因为 ggplot2 不知道我们要如何绘制数据 —— 我们仍然需要提供一个几何图形：

```R
g + geom_point()
```
![[../../assets/Data Analysis/ggplot2.png|450]]

因此，同样有 geom_line () - 线图，甚至可以组合，自定义颜色：
```R
 g + geom_line(color = "firebrick", size = 0.6) + geom_point(color = "blue", shape = "diamond", size = 0.2)
```
![[../../assets/Data Analysis/ggplot3.png|450]]

要调整点的形状，使用shape=(0 - 25)，参考：
![[../../assets/Coding/pointshapes.jpg|450]]

要自定义横竖坐标名称，使用：
```R
labs(x = "Year", y = "Temperature (°F)")
```

## 分组
```R
by_season <- ggplot(data = chic, aes(x = date, y = temp)) 

by_season + geom_point(aes(col = season)) # 季节的变化映射到色彩上，并自动添加了右边的图例；此外还可映射形状：shape = season
+ labs(x = "Year", y = "Temperature (°F)") 
```
![[../../assets/Data Analysis/ggplot4.png|450]]

### 改变图例

图例可在后面 + `theme (legend.position = "none")` 移除
仅移除标题 + `theme(legend.title = element_blank())`

改变标题最简单的方法是更改`labs`：
```R
by_season + geom_point(aes(col = season)) + labs(x = "Year", y = "Temperature (°F)", color = "Seasons\nindicated\nby colors:") 
```
![[../../assets/Data Analysis/legend1.png|100]]

或者使用`scale_color_discrete ()` 提供一个名称向量，还可更改labels
```R
scale_color_discrete(
    name = "Seasons:", 
    labels = c("Mar—May", "Jun—Aug", "Sep—Nov", "Dec—Feb"))
```
![[../../assets/Data Analysis/legend2.png|100]]


## 多面版图

首先处理年份：
```R
install.packages("lubridate")
library(lubridate)
chic$year <- year(chic$date)
```
这样就新加了一列年份。

```R
select_year <- c("1987", "1988", "1989", "1990")
g <- ggplot(chic %>% filter(year %in% select_year), aes(x = date, y = temp))
g + geom_point(color ="orangered", alpha =.3) + facet_grid(year ~ season)
# alpha调节透明度 - 从0（完全透明）到 1（不透明）
```
![[../../assets/Data Analysis/ggplot5.png|500]]
> 这里用到了筛选 - 用%>%传递给建立的想要的筛选目标向量

换个主题！
```R
g + geom_point(alpha =.3, aes(col = season)) + facet_grid(year ~ season)+ theme_minimal()
```
![[../../assets/Data Analysis/ggplot6.png|500]]

There are some inside themes
![[../../assets/Pasted image 20221107111711.png|500]]

### facet_wrap 和 facet_grid
[from jianshu](http://events.jianshu.io/p/07f7931a00db)
注意两者都是分面的方法；不同在于：   
+ `facet_wrap` 是基于一个因子进行设置，facets 表示形式为：~ 变量  
+  `facet_grid` 是基于两个因子进行设置，facets 表示形式为：变量～变量（行～列），如果把一个因子用点表示，也可以达到 facet_wrap 的效果，也可以用加号设置成两个以上变量  例如：变量 + 变量～变量 的形式，表示对三个变量设置分面。

另一个解释如下：  
![[../../assets/Coding/facet.png|500]]

## 双面板直方图

```R
ggplot(grouped_data, aes(x = values)) +
      geom_histogram(aes(fill=group)) +
      facet_wrap(~ group) +
      theme_bw() +
      theme(legend.position = "none")
```

要判断是否符合正态分布，可以通过绘制估计正态分布的形状来帮忙；我们可以给出每组的平均值和直方图顶部每组的标准差。

## 拟合曲线
```R
##tak our grouped data
grouped_data %>% 
  ##split it by the group variable
  group_by(group) %>% 
  ##produces one row for each group defined by the non-nested column (group)
  nest(data = c(values)) %>% 
  ##take the nested data
  mutate(y = map(data, 
                 ##use it to calculate the normal distribution using the $values in the grouped data
                 ~ dnorm(.$values, 
                         ##calcualte the mean of these values
                         mean = mean(.$values), 
                         ##and the sd of these values
                         sd = sd(.$values)
    ##the correct this for the binwidth we specified earlier                         
    ) * bw * sum(!is.na(.$values)))) %>% 
  ##convert the data back again from nested form
  unnest(c(data,y)) %>% 
  ##make the ggplot
  ggplot(aes(x = values)) +
  ##specify it is a histogram (and the bin width)
  geom_histogram(data = grouped_data, binwidth = 2,  aes(fill=group)) +
  ##add in the normal distribution we calcuated
  geom_line(aes(y = y)) + 
  ##facet it across two facets
  facet_wrap(~ group)
```
![[../../assets/Data Analysis/ggplot7.png|500]]