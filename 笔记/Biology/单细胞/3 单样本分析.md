质控 -> 过滤`subset()` -> 标准化`NormalizeData()` -> 识别HVGs`FindVariableFeatures()` -> 标准化`ScaleData()` -> 聚类`FindClusters/FindNeighbors` -> 作图`RunUMAP()` -> 

```R
rm(list = ls())
pbmc.data <- Read10X(data.dir = "filtered_gene_bc_matrices/hg19/")
pbmc <- suppressWarnings(CreateSeuratObject(counts = pbmc.data, project = "pbmc3k", min.cells = 3, min.features = 200))
ncol(pbmc) #有多少个细胞，ncol(pbmc.data)亦可 
```
# 储存的数据结构

## Assays

储存表达矩阵。默认情况下，我们是对Seurat中的RNA的Assay进行操作。可以通过`@active.assay`查看当前默认的assay，通过DefaultAssay()更改当前的默认assay。

counts 存储原始数据，是稀疏矩阵

data存储logNormalize() 规范化的data。总表达式对每个单元格的要素表达式度量进行标准化，将其乘以比例因子（默认为10,000），并对结果进行对数转换

scale.data存储ScaleData()缩放后的data，此步骤需要时间久。

## meta.data

元数据，对每个细胞的描述。一般的meta.data包括orig.ident, nCount_RNA, nFeature_RNA, 以及计算后的percent.mt，RNA_snn_res.0.5等

使用时有所区别：
+ `pbmc[['nCount_RNA']]` 取出所有细胞的nCount_RNA，包含细胞信息，数据框
+ 而`pbmc@meta.data$nCount_RNA`取出来的是单独nCount_RNA一列，是向量

```R
head(pbmc[['nCount_RNA']])
                 nCount_RNA
AAACATACAACCAC-1       2419
AAACATTGAGCTAC-1       4903
AAACATTGATCAGC-1       3147
AAACCGTGCTTCCG-1       2639
AAACCGTGTATGCG-1        980
AAACGCACTGGTAC-1       2163

head(pbmc@meta.data$nCount_RNA)
[1] 2419 4903 3147 2639  980 2163

```



# 数据质控

通常使用的QC指标：
+ 每个细胞被检测到的unique genes数量（低质量的细胞或空的液滴含有unique genes较少；细胞双重态或多重态检测到异常高unique genes）；
+ 细胞内被检测到的features的总数目（与unique genes高度相关）；
+ 线粒体基因占比（低质量/将要死去的细胞经常出现线粒体基因占比过高）。

其中人类参考基因中线粒体基因是以“MT-”开头的，而在小鼠中是以“mt-”开头的（`-`是不可少的）
Ps: `[]`用于索引向量、列表、数据框。 `[[]]`用于索引获得列表、数据框的具体值。

查看线粒体基因占比：
```R
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
head(pbmc@meta.data,5)

---
 
 
                 orig.ident nCount_RNA nFeature_RNA  percent.mt
AAACATACAACCAC-1	pbmc3k	2419	779	3.0177759
AAACATTGAGCTAC-1	pbmc3k	4903	1352	3.7935958
AAACATTGATCAGC-1	pbmc3k	3147	1129	0.8897363
AAACCGTGCTTCCG-1	pbmc3k	2639	960	1.7430845
AAACCGTGTATGCG-1	pbmc3k	980	521	1.2244898

```

## 可视化：

```R
VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
```
![[../../assets/scRNA/3.1.png]]

```R
plot1 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
```
![[../../assets/scRNA/3.2.png]]

# 细胞分群

## 过滤

```R
# 官方推荐过滤掉独特特征计数超过2500或小于200的细胞，或者过滤掉超过5%线粒体基因比例的细胞
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
pbmc
```

## 标准化

```R
pbmc <- NormalizeData(pbmc, normalization.method = "LogNormalize", scale.factor = 10000)
```

`pbmc <- NormalizeData(pbmc)` 亦可，因为上述用的是默认参数。

Ps：如果有了一个TPM的count矩阵，那么就不需要使用Seurat::NormalizeData()操作，因为TPM已经根据测序深度进行了归一化，只需要进行log降维度即可。

## 识别差异基因HVGs (highly variable features)

在细胞与细胞间进行比较，选择表达量差别最大的(也即是同一个基因在有的细胞中表达量很高，同时在部分细胞中表达很少)，利用FindVariableFeatures函数，会计算一个mean-variance 结果，也就是给出表达量均值和方差的关系并且得到top variable features。

```R
pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000) # 两千个高变基因
top10 <- head(VariableFeatures(pbmc), 10) # 查看十个程度最强的高变基因
top10
```

method有三种：
+ (默认) vst：对方差(variance)和均值(mean)都取log值+loess线性拟合
+ mean.var.plot方法：average expression & dispersion (for each feature) + z-scores
+ dispersion方法：the highest dispersion values

```R
par(mfrow=c(1, 1))
plot1 <- VariableFeaturePlot(pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
combined_plot <- grid.arrange(plot1, plot2, nrow = 2, heights = c(1, 1)) # "gridExtra"包可以实现上下分图
```
![[../../assets/scRNA/3.3.png]]

# 下游分析

## 数据标准化（scale）

实现数据的线性转换(scaling)，也是降维处理之前的标准预处理。 主要利用了`ScaleData`函数，
之前归一化（normalize）作log处理，它是对所有基因的表达量统一对待的，最后放在了一个起跑线上。但是为了真正找到差异，我们还要基于这个起跑线，考虑不同样本对表达量的影响

```R
pbmc <- ScaleData(pbmc, vars.to.regress = "percent.mt") # vars.to.regress用于回归的参数，它指定了要从数据中回归掉的变量，这里就是为了移除线粒体细胞等的影响
```

> Normalization “normalizes” within the cell for the difference in sequenicng depth / mRNA throughput. 主要着眼于样本的文库大小差异 
> 
> Scaling “normalizes” across the sample for differences in range of variation of expression of genes . 主要着眼于基因的表达分布差异

## 降维

降维是指通过保留一些比较重要的特征，去除一些冗余的特征，减少数据特征的维度。而特征的重要性取决于该特征能够表达多少数据集的信息，也取决于使用什么方法进行降维。一般情况会先使用线性的降维方法再使用非线性的降维方法，通过结果去判断哪种方法比较合适。

### PCA (principal component analysis)线性降维：

```R
pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))
print(pbmc[["pca"]], dims = 1:3, nfeatures = 5)

---
PC_ 1 
Positive:  CST3, TYROBP, LST1, AIF1, FTL 
Negative:  MALAT1, LTB, IL32, IL7R, CD2 
PC_ 2 
Positive:  CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DQB1 
Negative:  NKG7, PRF1, CST7, GZMA, GZMB 
PC_ 3 
Positive:  HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPA1 
Negative:  PPBP, PF4, SDPR, SPARC, GNG11 
```

默认选择之前鉴定的差异基因（2000个）作为input，但可以使用features进行设置；默认分析的主成分数量是5个

上述print结果可以可视化：

```R
VizDimLoadings(pbmc, dims = 2:3, reduction = "pca") # dims指定任意两个相邻PC
```

提取两个主成分（默认前两个，当然可以修改dims选项）绘制散点图：

```R
DimPlot(pbmc, reduction = "pca")
```
![[../../assets/scRNA/3.4.png]]


接下来是热力图，每个细胞和基因都根据PCA结果得分进行了排序，默认画前30个基因（nfeatures设置），1个主成分(dims设置)，细胞数没有默认值（cells设置），balanced表示正负得分的基因各占一半。

它可以查看数据中异质性的主要来源，并可以确定哪些PCA维度可以用于下一步的下游分析。细胞和特征根据PCA的分数进行排序：

```R
DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE)
```
![[../../assets/scRNA/3.5.png]]


降维后怎么选择合适数量的主成分来代表整个数据集？最简单的方法就是以下代码作图，并查看拐点：

```R
ElbowPlot(pbmc)
```

或者：

```R
pbmc <- JackStraw(pbmc, num.replicate = 100)
pbmc <- ScoreJackStraw(pbmc, dims = 1:20)
JackStrawPlot(pbmc, dims = 1:20)
```
![[../../assets/scRNA/3.6.png]]

第一种方式在PC9-10周围观察到“elbow ”，第二种方式在10-12台PC之后，重要性似乎急剧下降。 由此可以用10PC。在选择该参数时候，**尽量偏高一点**。

## 聚类

```R
pbmc <- FindNeighbors(pbmc, dims = 1:10) # 上面选了10PC
pbmc <- FindClusters(pbmc, resolution = 0.5) # resolution参数表达聚类的分辨率，值越大得到的cluster越多（看的越清楚），对于3K细胞的单细胞数据0.4-1.2 通常会得到较好的结果。
```

此时作图，发现难以通过一个点代表一个细胞的PCA降维可视化图进行呈现，因为在二维或三维的效果下，可视化图会有大量的点（细胞）重叠，仅通过2~3个主成分特征无法很好地将不同亚群之间的数据区分开来：

```R
DimPlot(pbmc, dims = 1:2, reduction = "pca")
```
![[../../assets/scRNA/3.7.png]]

## 非线性降维(UMAP/tSNE)

UMAP与tSNE可以将高维空间的结构特征投影至低维空间（二维、三维）之中：在得到低维分布的具体特征后，计算降维过程中空间位置的信息缺失，优化低维分布的位置信息，保留高维特征信息。这两个降维方式也因此成为了单细胞转录组最主要的可视化方式。

```R
pbmc <- RunUMAP(pbmc, dims = 1:10)
#可以设置`LABEL=TRUE`或使用LabelClusters函数来帮助标记单个群集
umap <- DimPlot(pbmc, reduction = "umap")

pbmc <- RunTSNE(pbmc, dims = 1:10)
tsne <- DimPlot(pbmc, reduction = "tsne", label = TRUE)

umap + tsne
```
![[../../assets/scRNA/3.8.png]]

## 找差异表达基因（cluster biomarker）

目的是根据表达量不同这个特征而分出不同细胞群的基因们（就是找具有生物学意义的HVGs -> 即biomarkers） marker可以理解成标记，就是一看到有这些基因，就说明是这个细胞群体

`FindMarkers()`：比较两个特定cluster之间的基因表达

```R
# 找到cluster1中的marker基因
cluster1.markers <- FindMarkers(pbmc, ident.1 = 1, min.pct = 0.25)
head(cluster1.markers, n = 5)
```

其中min.pct的意思是：一个基因在任何两群细胞中的占比最低不能低于多少。

一步到位的办法`FindAllMarkers()`（对所有cluster都比较一下，并只挑出来正表达marker），它默认会对单独的一个细胞群与其他几群细胞进行比较找到正、负表达biomarker（这里的正负有点上调、下调基因的意思；正marker表示在我这个cluster中表达量高，而在其他的cluster中低）：

```R
pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
# 这一步过滤好好理解(进行了分类、排序、挑前2个)
pbmc.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_log2FC) # 新版函数用avg_log2FC而不是avg_logFC
```

速度快的函数：`marker_cosg <- cosg(sce, groups='all', assay='RNA', slot='data', mu=1, n_genes_user=100)`

### 多种可视化方式

```R
FeaturePlot(pbmc, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP", "CD8A"))
```
